---
layout: post
published: true
title: RPi4 - Docker with IPv6 and Docker Compose
subtitle: Part 3
tags: [raspberrypi, docker, ipv6, docker-compose, mtr, ddclient]
---

The Raspberry Pi 4 is powerful enough to run multiple Docker containers with decent performances. The goal here is to use Docker as much as possible to separate services and responsibilities and ease the maintenance and the updates.

## Docker installation

Docker is properly supported on Raspbian Buster and the installation is straight forward

```console
$ sudo su

# curl -sSL https://get.docker.com | sh
# usermod -aG docker [USERNAME]
```

After the `usermod` command, you need to logout/login to get permission to run docker commands.

Let's check that Docker is running properly

```console
$ docker run hello-world
$ docker system prune -a
```

### IPv6 support

By default, IPv6 is not supported by Docker and requires some some additional configuration in the file `/etc/docker/daemon.json`.

In this file, we indicate to Docker to use our local DNS server and we activate the IPv6 feature. We also need to specify a range of available IPv6 for Docker (it has to be in the range assigned to router).

```console
$ sudo tee /etc/docker/daemon.json > /dev/null << "EOF"
{
  "dns": ["172.17.0.1"],
  "ipv6": true,
  "fixed-cidr-v6": "2404:e801:XXXX:XXXX:5000::/80"
}
EOF

$ sudo systemctl restart docker
```

### NDP Proxy

The Raspberry Pi doesn't manage an IPv6 prefix directly and is a simple client for the Linksys router. The IPv6 prefix is managed by the router and the containers are not directly accessible (they belongs to another network segment).
The solution is to enable ND Proxy (Neighbour Discovery Proxy). Basically, this protocol allows bridging the router network and the docker network. The Raspberry Pi will reply to the Neighbor Solicitation messages sent on the network on the behalf of the containers and they become reachable.

Let's start by activating the `proxy_ndp` option in the kernel

```console
$ echo "net.ipv6.conf.eth0.proxy_ndp=1" | sudo tee -a /etc/sysctl.conf
$ sudo sysctl -p
```

Once the `proxy_ndp` is activated, you need to register the IPv6 addresses you want to expose.

- One way is to enable proxying per container with a command like `ip -6 neigh add proxy 2404:e801:xxxx:xxxx:5000::xxxx dev eth0`. It's a manual operation and it requires some maintenance when you add/remove containers.
- A better way is to use `ndppd`, a small daemon that can proxy a whole subnet and doesn't require any maintenance.

  ```console
  $ sudo apt install ndppd
  $ sudo tee /etc/ndppd.conf > /dev/null << "EOF"
  route-ttl 5000
  proxy eth0
  {
      router yes
      timeout 500
      ttl 30000

      rule 2404:e801:xxxx:xxxx:5000::/80
      {
          auto
      }
  }
  EOF

  $ sudo systemctl restart ndppd
  ```

### Test

You can run a simple container to check IPv6 is properly supported

```console
$ docker run -it --rm alpine ash -c "ip -6 addr; ip -6 route; ping -6 -c4 www.google.com"
```

## Docker Compose

*(based on [https://www.berthon.eu/2019/revisiting-getting-docker-compose-on-raspberry-pi-arm-the-easy-way/](https://www.berthon.eu/2019/revisiting-getting-docker-compose-on-raspberry-pi-arm-the-easy-way/))*

Docker [Compose](https://github.com/docker/compose) is a tool to define and run Docker containers using YAML configuration files. Unfortunately, Compose is not available for ARM architecture as an ELF binary. You can install it using `pip install docker-compose` but it requires to install a lot of Python3 dependencies on the Raspberry Pi.

A smart solution is to build `compose` inside a container and to retrieve the built ELF executable. This way, you don't have to install any package on the host.

```console
-- Create a docker base folder
$ sudo mkdir /opt/docker
$ sudo chmod 770 /opt/docker
$ sudo chgrp docker /opt/docker

-- Retrieve latest stable compose sources
$ mkdir /opt/docker/compose-build && cd /opt/docker/compose-build
$ wget -qO- https://github.com/docker/compose/archive/1.24.1.tar.gz | tar xzvf -
$ cd compose-1.24.1/

-- Fix the sources (thanks to J-C Berthon)
$ sed -i -e 's:^VENV=/code/.tox/py36:VENV=/code/.venv; python3 -m venv $VENV:' script/build/linux-entrypoint
$ sed -i -e '/requirements-build.txt/ i $VENV/bin/pip install -q -r requirements.txt' script/build/linux-entrypoint

-- Create the image to build docker-compose (take a coffee)
$ docker build -t docker-compose-build:armhf -f Dockerfile.armhf .

-- Build docker-compose using the created image (finish the coffee pot)
$ docker run --rm --entrypoint="script/build/linux-entrypoint" -v $(pwd)/dist:/code/dist "docker-compose-build:armhf"

-- Retrieve the ELF binary
$ sudo cp dist/docker-compose-Linux-armv7l /usr/local/bin/docker-compose
$ sudo chown root:root /usr/local/bin/docker-compose
$ sudo chmod 0755 /usr/local/bin/docker-compose

-- Test
$ docker-compose version
docker-compose version 1.24.1, build unknown
docker-py version: 3.7.3
CPython version: 3.6.9
OpenSSL version: OpenSSL 1.1.1c  28 May 2019

-- Cleanup
$ cd ~/
$ rm -fR /opt/docker/compose-build
$ docker images docker-compose-build -q | xargs docker rmi
```

## Bonus - Run MTR in a Docker container

MTR (My traceroute) is a nice network diagnostic tool but if you don't want to install it with its dependencies on the Raspberry Pi, you can run it through Docker.

```console
-- Create a simple Dockerfile
$ mkdir /opt/docker/mtr
$ tee /opt/docker/mtr/Dockerfile > /dev/null << "EOF"
FROM alpine:latest
MAINTAINER Gregoire Pailler <gregoire@pailler.fr>
RUN apk add --no-cache mtr
ENTRYPOINT ["/usr/sbin/mtr"]
EOF

-- Build the image
$ docker build -t mtr /opt/docker/mtr

-- Add an alias to run mtr like any other command
$ tee -a ~/.bash_aliases > /dev/null << "EOF"
alias mtr='docker run --rm -it mtr'
EOF

-- Reload the aliases
$ source ~/.bash_aliases

-- Test !
$ mtr -6 ipv6.google.com
```

## Extra bonus - Run ddclient in a Docker container

DDClient is a small utility used to update dynamic DNS entries for accounts on dynamic DNS services. It allows to access the Raspberry Pi from everywhere.

Create a compose file with the following configuration

```console
$ mkdir /opt/docker/ddclient && cd /opt/docker/ddclient
$ tee /opt/docker/ddclient/docker-compose.yml > /dev/null << "EOF"
version: "3"

services:
  ddclient:
    image: linuxserver/ddclient:latest
    container_name: ddclient
    environment:
      TZ: 'Asia/Singapore'
      PUID: 1000
      PGID: 1000
    volumes:
      - './ddclient.conf:/config/ddclient.conf:ro'
    restart: unless-stopped
EOF
```

And create a `ddclient.conf` file to update a DynDNS entry (the settings are dependent of your provider).

```console
$ export DD_LOGIN=login
$ export DD_PASSWORD=password
$ export DD_SERVER=www.ovh.com
$ export DD_HOST=host.domain.tld

$ tee /opt/docker/ddclient/ddclient.conf > /dev/null << EOF
daemon=300
syslog=yes
protocol=dyndns2
use=web, web=api.ipify.org
server=${DD_SERVER}
login=${DD_LOGIN}
password='${DD_PASSWORD}'
${DD_HOST}
EOF
```

Start the container and check the logs to ensure DDClient works properly and updates the DynDNS entry.

```console
$ docker-compose -f /opt/docker/ddclient/docker-compose.yml up -d
$ docker-compose -f /opt/docker/ddclient/docker-compose.yml logs -f
```

Now you can open the port 22 on your router and forward it to the Raspberry Pi to get an SSH access from everywhere. You can check the port is properly open by using a network scanner like [http://www.ipv6scanner.com/cgi-bin/main.py](http://www.ipv6scanner.com/cgi-bin/main.py)

![Knock knock]({{site.baseurl}}/img/201910/ipv6-scanner_thumb.jpg)