---
layout: post
published: true
title: Raspberry Pi 4 full configuration - part 3
subtitle: Docker with IPv6 and Docker Compose
tags: [raspberrypi, docker, ipv6, docker-compose, mtr]
---

The Raspberry Pi 4 is powerful enough to run multiple Docker containers with decent performances. The goal here is to use Docker as much as possible to separate services and responsibilities and ease the maintenance and the updates.

## Docker installation

Docker is properly supported on Raspbian Buster and the installation is straight forward

```console
$ sudo su

# curl -sSL https://get.docker.com | sh
# usermod -aG docker [USERNAME]
```

I need to logout/login to gain permission to run docker commands.

Let's check that Docker is running properly

```console
$ docker run hello-world
$ docker system prune -a
```

### IPv6 support

By default, IPv6 is not supported by Docker and requires some some additional configuration.

I configure the local DNS server and activate IPv6. I also specify a range of available IPs for Docker (it has to be in the range assigned to my router).
```console
$ sudo tee /etc/docker/daemon.json > /dev/null << "EOF"
{
  "dns": ["172.17.0.1"],
  "ipv6": true,
  "fixed-cidr-v6": "2404:e801:XXXX:XXXX:5000::/80"
}
EOF

$ sudo systemctl restart docker
```

### NDP Proxy

An  extra complication is the Raspberry Pi doesn't manage an IPv6 prefix directly and is a simple client for my Linksys router. My IPv6 prefix is managed by the router and the containers are not directly accessible on the router network (they belongs to another network segment).
The solution is to enable ND Proxy (Neighbour Discovery Proxy). Basically, this protocol allows bridging the router network and the docker network. The Raspberry Pi will reply to the Neighbor Solicitation messages sent on the network on the behalf of the containers and they become reachable.

Let's start by activating the proxy_ndp option
```console
$ sudo tee -a /etc/sysctl.conf > /dev/null << "EOF"
net.ipv6.conf.eth0.proxy_ndp=1
EOF

$ sudo sysctl -p
```

Once proxy_ndp is activated, I need to register the IPv6 I want to expose. 

- One way is to enable proxying per container with a command like `ip -6 neigh add proxy 2404:e801:xxxx:xxxx:5000::xxxx dev eth0`. It's a manual operation and it requires some maintenance when I add/remove containers.
- A better way is to use `ndppd`, a small daemon that can proxy a whole subnet and doesn't require any maintenance.

  ```console
  $ sudo apt install ndppd
  $ sudo tee /etc/ndppd.conf > /dev/null << "EOF"
  route-ttl 5000
  proxy eth0
  {
      router yes
      timeout 500
      ttl 30000
  
      rule 2404:e801:xxxx:xxxx:5000::/80
      {
          auto
      }
  }
  EOF
  
  $ sudo systemctl restart ndppd
  ```

### Test

After the configuration, I run a simple container to check the IPv6 support

```console
$ docker run -it --rm alpine ash -c "ip -6 addr; ip -6 route; ping -6 -c4 www.google.com"
```

## Docker Compose

*(based on [https://www.berthon.eu/2019/revisiting-getting-docker-compose-on-raspberry-pi-arm-the-easy-way/])*

Docker [Compose](https://github.com/docker/compose) is a tool to define and run Docker applications using YAML configuration files. In a single file, you can define all options required to launch a Docker container and even configure multi-containers applications.

Unfortunately, Compose is not available for ARM architecture as an ELF binary. I can install it using `pip install docker-compose` but it requires to install a lot of Python3 dependencies on the Raspberry Pi.

However I can use the power of Docker to build `compose` inside a container and to retrieve the ELF executable. This way, I don't have to install any package on the host.

```console
-- Retrieve latest stable compose sources
$ mkdir /opt/docker/compose-build && cd /opt/docker/compose-build
$ wget -qO- https://github.com/docker/compose/archive/1.24.1.tar.gz | tar xzvf -
$ cd compose-1.24.1/

-- Fix the sources (thanks to J-C Berthon)
$ sed -i -e 's:^VENV=/code/.tox/py36:VENV=/code/.venv; python3 -m venv $VENV:' script/build/linux-entrypoint
$ sed -i -e '/requirements-build.txt/ i $VENV/bin/pip install -q -r requirements.txt' script/build/linux-entrypoint

-- Create the image to build docker-compose (take a coffee)
$ docker build -t docker-compose-build:armhf -f Dockerfile.armhf .

-- Build docker-compose using the created image (finish the coffee pot)
$ docker run --rm --entrypoint="script/build/linux-entrypoint" -v $(pwd)/dist:/code/dist "docker-compose-build:armhf"

-- Retrieve the ELF binary
$ sudo cp dist/docker-compose-Linux-armv7l /usr/local/bin/docker-compose
$ sudo chown root:root /usr/local/bin/docker-compose
$ sudo chmod 0755 /usr/local/bin/docker-compose

-- Test
$ docker-compose version
docker-compose version 1.24.1, build unknown
docker-py version: 3.7.3
CPython version: 3.6.9
OpenSSL version: OpenSSL 1.1.1c  28 May 2019

-- Cleanup
$ cd
$ rm -fR /opt/docker/compose-build
$ docker images docker-compose-build -q | xargs docker rmi
```

## Bonus - Run MTR through Docker

MTR (My traceroute) is a very nice network diagnostic tool but I don't want to install it with its dependencies on the Raspberry Pi. I will run it through Docker instead.

```console
-- Create a folder to store all our Docker experimentations
$ sudo mkdir /opt/docker
$ sudo chmod 770 /opt/docker
$ sudo chgrp docker /opt/docker

-- Create our simple Dockerfile
$ mkdir /opt/docker/mtr
$ tee /opt/docker/mtr/Dockerfile > /dev/null << "EOF"
FROM alpine:latest
RUN apk add --no-cache mtr
ENTRYPOINT ["/usr/sbin/mtr"]
EOF

-- Build the image
$ docker build -t mtr /opt/docker/mtr

-- Add an alias to run mtr as usual
$ tee -a ~/.bash_aliases > /dev/null << "EOF"
alias mtr='docker run --rm -it mtr'
EOF

-- Reload the aliases
$ source ~/.bash_aliases

-- Test !
$ mtr -6 ipv6.google.com
```

[Part 2 - Custom DNS with Dnsmasq]({% post_url 2019-10-07-pi4-part2 %})

[Part 4 - Pi-Hole in a Docker container](#)